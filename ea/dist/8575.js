"use strict";(self.webpackChunkvolumetric_atmospheric_scattering=self.webpackChunkvolumetric_atmospheric_scattering||[]).push([[8575],{8575:(t,e,r)=>{function o(t){return Math.floor(t/8)}function s(t){return 1<<t%8}r.d(e,{OptimizeIndices:()=>i});class n{constructor(t){this.size=t,this._byteArray=new Uint8Array(Math.ceil(this.size/8))}get(t){if(t>=this.size)throw new RangeError("Bit index out of range");const e=o(t),r=s(t);return 0!==(this._byteArray[e]&r)}set(t,e){if(t>=this.size)throw new RangeError("Bit index out of range");const r=o(t),n=s(t);e?this._byteArray[r]|=n:this._byteArray[r]&=~n}}function i(t){const e=[],r=t.length/3;for(let o=0;o<r;o++)e.push([t[3*o],t[3*o+1],t[3*o+2]]);const o=new Map;for(let t=0;t<e.length;t++){const r=e[t];for(const e of r){let r=o.get(e);r||o.set(e,r=[]),r.push(t)}}const s=new n(r),i=[],c=t=>{const r=[t];for(;r.length>0;){const t=r.pop();if(!s.get(t)){s.set(t,!0),i.push(e[t]);for(const n of e[t]){const t=o.get(n);if(!t)return;for(const e of t)s.get(e)||r.push(e)}}}};for(let t=0;t<r;t++)s.get(t)||c(t);let f=0;for(const e of i)t[f++]=e[0],t[f++]=e[1],t[f++]=e[2]}}}]);