"use strict";(self.webpackChunkvolumetric_atmospheric_scattering=self.webpackChunkvolumetric_atmospheric_scattering||[]).push([[9928],{9928:(e,a,n)=>{n.r(a),n.d(a,{Dispose:()=>l,DumpData:()=>u,DumpDataAsync:()=>m,DumpFramebuffer:()=>c,DumpTools:()=>d});var t=n(4255),r=n(998),s=n(4867),i=n(6315),o=n(1137);let p=null;async function c(e,a,n,t,r="image/png",s,i){const o=await n.readPixels(0,0,e,a);u(e,a,new Uint8Array(o.buffer),t,r,s,!0,void 0,i)}async function m(e,a,c,m="image/png",u,d=!1,f=!1,g){if(c instanceof Float32Array){const e=new Uint8Array(c.length);let a=c.length;for(;a--;){const n=c[a];e[a]=Math.round(255*(0,s.OQ)(n))}c=e}const w=await async function(){return p||(p=async function(){const e=i.q.LastCreatedEngine?.createCanvas(100,100)??new OffscreenCanvas(100,100);e instanceof OffscreenCanvas&&o.V.Warn("DumpData: OffscreenCanvas will be used for dumping data. This may result in lossy alpha values.");const{ThinEngine:a}=await Promise.resolve().then(n.bind(n,6514));if(!a.IsSupported){if(!e.getContext("bitmaprenderer"))throw new Error("DumpData: No WebGL or bitmap rendering context available. Cannot dump data.");return{canvas:e}}const r=new a(e,!1,{preserveDrawingBuffer:!0,depth:!1,stencil:!1,alpha:!0,premultipliedAlpha:!1,antialias:!1,failIfMajorPerformanceCaveat:!1});i.q.Instances.pop(),i.q.OnEnginesDisposedObservable.add(e=>{r&&e!==r&&!r.isDisposed&&0===i.q.Instances.length&&l()}),r.getCaps().parallelShaderCompile=void 0;const s=new t.J(r),{passPixelShader:p}=await n.e(9820).then(n.bind(n,9820)),c=new t.$({engine:r,name:p.name,fragmentShader:p.shader,samplerNames:["textureSampler"]});return{canvas:e,dumpEngine:{engine:r,renderer:s,wrapper:c}}}()),await p}();return await new Promise(async n=>{if(w.dumpEngine){const n=w.dumpEngine;n.engine.setSize(e,a,!0);const t=n.engine.createRawTexture(c,e,a,5,!1,!d,1);n.renderer.setViewport(),n.renderer.applyEffectWrapper(n.wrapper),n.wrapper.effect._bindTexture("textureSampler",t),n.renderer.draw(),t.dispose()}else{const n=w.canvas.getContext("bitmaprenderer");w.canvas.width=e,w.canvas.height=a;const t=new ImageData(e,a);t.data.set(c);const r=await createImageBitmap(t,{premultiplyAlpha:"none",imageOrientation:d?"flipY":"from-image"});n.transferFromImageBitmap(r)}r.S0.ToBlob(w.canvas,e=>{if(!e)throw new Error("DumpData: Failed to convert canvas to blob.");void 0!==u&&r.S0.DownloadBlob(e,u);const a=new FileReader;a.onload=e=>{const a=e.target.result;n(a)},f?a.readAsArrayBuffer(e):a.readAsDataURL(e)},m,g)})}function u(e,a,n,t,r="image/png",s,i=!1,o=!1,p){void 0!==s||t||(s=""),m(e,a,n,r,s,i,o,p).then(e=>{t&&t(e)})}function l(){p&&(p?.then(e=>{e.canvas instanceof HTMLCanvasElement&&e.canvas.remove(),e.dumpEngine&&(e.dumpEngine.engine.dispose(),e.dumpEngine.renderer.dispose(),e.dumpEngine.wrapper.dispose())}),p=null)}const d={DumpData:u,DumpDataAsync:m,DumpFramebuffer:c,Dispose:l};r.S0.DumpData=u,r.S0.DumpDataAsync=m,r.S0.DumpFramebuffer=c}}]);